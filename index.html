<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Navaraa Staking — DApp</title>

  <!-- Simple modern reset + utilities -->
  <style>
    :root{
      --bg:#0f1724; --card:#0b1220; --muted:#94a3b8; --accent:#7c3aed; --glass: rgba(255,255,255,0.03);
      --success:#16a34a; --danger:#ef4444; --glass-2: rgba(255,255,255,0.02);
      --radius:14px; --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg,var(--bg) 0%, #061021 100%);
      color: #e6eef8;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      padding:24px;
    }

    /* container */
    .wrap{
      max-width:1100px; margin:0 auto; display:grid; grid-template-columns: 1fr; gap:20px;
    }

    header{
      display:flex; gap:16px; align-items:center; justify-content:space-between;
    }
    .brand{display:flex; gap:12px; align-items:center;}
    .logo{
      width:56px; height:56px; border-radius:12px; background:linear-gradient(135deg,var(--accent),#2dd4bf);
      display:flex; align-items:center; justify-content:center; font-weight:700; font-family:var(--mono);
      box-shadow: 0 6px 20px rgba(124,58,237,0.18);
    }
    h1{font-size:20px;margin:0}
    p.sub{margin:0;color:var(--muted); font-size:13px}

    .controls{display:flex; gap:12px; align-items:center;}
    .btn{
      background:var(--accent); color:white; border:none; padding:10px 14px; border-radius:10px; cursor:pointer;
      font-weight:600; box-shadow: 0 6px 18px rgba(124,58,237,0.14);
    }
    .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06); color:var(--muted); box-shadow:none}
    .btn[disabled]{opacity:.5; cursor:not-allowed}

    /* main grid */
    .grid{
      display:grid; grid-template-columns: 380px 1fr; gap:20px;
    }
    @media (max-width:920px){
      .grid{grid-template-columns:1fr}
      .brand h1{font-size:18px}
      .logo{width:48px;height:48px}
    }

    /* card */
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:var(--radius); padding:18px; box-shadow: 0 6px 30px rgba(2,6,23,0.6); border:1px solid rgba(255,255,255,0.03);
    }
    .muted{color:var(--muted); font-size:13px}
    .row{display:flex; gap:12px; align-items:center; justify-content:space-between}
    .field{display:flex; flex-direction:column; gap:8px; margin-bottom:10px}
    label{font-size:13px; color:var(--muted)}
    input[type="text"], input[type="number"]{
      background:var(--glass); border:1px solid rgba(255,255,255,0.03); padding:10px 12px; border-radius:10px; color:inherit;
      outline:none; font-size:15px;
    }
    .small{font-size:13px;color:var(--muted)}
    .badge{background:var(--glass-2); padding:6px 10px; border-radius:999px; font-weight:600; font-size:13px; color:var(--muted)}

    /* stakes list */
    .stake-list{display:flex; flex-direction:column; gap:10px; max-height:420px; overflow:auto; padding-right:6px}
    .stake-item{display:flex; gap:12px; align-items:center; padding:10px; border-radius:10px; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00)); border:1px solid rgba(255,255,255,0.02)}
    .stake-left{flex:1}
    .stake-meta{display:flex; gap:8px; align-items:center; color:var(--muted); font-size:13px}
    .tiny{font-size:12px;color:var(--muted)}
    .green{color:var(--success)}
    .red{color:var(--danger)}
    .pill{background:rgba(255,255,255,0.03); padding:6px 8px;border-radius:8px; font-weight:600; font-size:13px}

    footer{margin-top:20px; color:var(--muted); font-size:13px; text-align:center}
    a.link{color:inherit; text-decoration:underline; color:var(--muted)}
    .error{color:var(--danger); font-weight:700}
    .ok{color:var(--success); font-weight:700}
    .tiny-muted{font-size:12px;color:var(--muted)}

    /* spinner */
    .spinner{width:16px;height:16px;border-radius:50%; border:2px solid rgba(255,255,255,0.08); border-top-color:var(--accent); animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}

    /* table for actions */
    .actions{display:flex; flex-direction:column; gap:12px}
    .flex{display:flex; gap:8px; align-items:center}
    .checkbox{width:18px;height:18px}
  </style>

  <!-- Ethers.js CDN (v5) -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.min.js"></script>

  <!-- WalletConnect v1 provider (for mobile wallets) -->
  <script src="https://cdn.jsdelivr.net/npm/@walletconnect/web3-provider@1.8.0/dist/umd/index.min.js"></script>

  <!-- Web3Modal v1 (light) for easy wallet selection -->
  <script src="https://cdn.jsdelivr.net/npm/web3modal@1.9.12/dist/index.min.js"></script>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="logo">NV</div>
        <div>
          <h1>Navaraa Staking</h1>
          <p class="sub">Stake NAVAA — Earn up to 4x · Referrals · Polygon</p>
        </div>
      </div>

      <div class="controls">
        <div id="networkBadge" class="badge">Polygon</div>
        <div id="addrShort" class="tiny-muted">Not connected</div>
        <button id="connectBtn" class="btn">Connect Wallet</button>
      </div>
    </header>

    <main class="grid">
      <!-- left column: user + forms -->
      <section class="card">
        <div class="row" style="margin-bottom:12px;">
          <div>
            <div class="muted">Your Wallet</div>
            <div style="display:flex; gap:8px; align-items:center; margin-top:6px;">
              <div id="walletBalance" class="badge">0 NAVAA</div>
              <div id="totalPending" class="pill">Pending: 0</div>
            </div>
            <div class="tiny-muted" style="margin-top:6px;">Token: <span id="tokenAddrShort"></span></div>
          </div>
          <div style="text-align:right;">
            <div class="muted">Contract</div>
            <div class="tiny-muted" id="contractAddrShort"></div>
            <div class="tiny-muted" id="managementWallet"></div>
          </div>
        </div>

        <hr style="border:none;border-top:1px solid rgba(255,255,255,0.02); margin:10px 0 14px;" />

        <!-- Stake form -->
        <div class="field">
          <label>Amount to stake (NAVAA)</label>
          <input id="stakeAmount" type="number" placeholder="170000 (minimum)" min="0" step="1" />
        </div>
        <div class="field">
          <label>Referrer (optional address)</label>
          <input id="referrer" type="text" placeholder="0x... or leave empty for management wallet" />
          <div class="tiny-muted">If left empty, management wallet will be used as referrer.</div>
        </div>
        <div class="flex">
          <button id="stakeBtn" class="btn">Stake Tokens</button>
          <button id="approveBtn" class="btn ghost">Approve Token</button>
          <div id="stakeSpinner" style="display:none" class="spinner"></div>
        </div>

        <hr style="border:none;border-top:1px solid rgba(255,255,255,0.02); margin:14px 0;" />

        <div class="actions">
          <div>
            <div class="muted">Claim Rewards</div>
            <div class="tiny-muted">Select the stakes below and click <strong>Claim</strong></div>
            <div style="margin-top:8px;">
              <button id="claimBtn" class="btn">Claim Selected</button>
              <div id="claimSpinner" style="display:none" class="spinner"></div>
            </div>
          </div>

          <div>
            <div class="muted">Withdraw Principal (Matured)</div>
            <div class="tiny-muted">Select matured stakes and click <strong>Withdraw</strong></div>
            <div style="margin-top:8px;">
              <button id="withdrawBtn" class="btn">Withdraw Selected</button>
              <div id="withdrawSpinner" style="display:none" class="spinner"></div>
            </div>
          </div>
        </div>

      </section>

      <!-- right column: stakes list & logs -->
      <section class="card">
        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:12px;">
          <div>
            <div class="muted">Your Stakes</div>
            <div class="tiny-muted">Indexes, amounts, start time, pending reward (live)</div>
          </div>
          <div style="display:flex; gap:8px; align-items:center;">
            <button id="refreshBtn" class="btn ghost">Refresh</button>
            <div id="loadingLives" style="display:none" class="tiny-muted"><span class="spinner"></span></div>
          </div>
        </div>

        <div class="stake-list" id="stakeList">
          <!-- dynamic stake items -->
        </div>

        <hr style="border:none;border-top:1px solid rgba(255,255,255,0.02); margin:14px 0;" />
        <div style="display:flex; justify-content:space-between; gap:12px; align-items:center;">
          <div class="tiny-muted">Logs</div>
          <button id="clearLog" class="btn ghost">Clear</button>
        </div>
        <pre id="log" style="margin-top:10px; max-height:160px; overflow:auto; padding:10px; border-radius:10px; background:rgba(0,0,0,0.15)">Ready.</pre>
      </section>
    </main>

    <footer>
      <div>Copy-paste ready — Host with GitHub Pages. &nbsp;|&nbsp; Built for Polygon Mainnet</div>
    </footer>
  </div>

  <script>
  /************************************************************************
   * Configuration + constants (change only if needed)
   ************************************************************************/
  const CONFIG = {
    NETWORK_NAME: "Polygon",
    CHAIN_ID: 137,
    RPC: "https://polygon-rpc.com/", // public RPC (you can replace)
    // Provided contract addresses & ABI (from user)
    STAKING_CONTRACT_ADDRESS: "0x9fd473975cecd4587d78eb71f4498dde778c4b83",
    TOKEN_CONTRACT_ADDRESS:   "0x23b7a4c2ec9d742b5b1698149e812ca1e10d3e73",
    // ABI (shortened/complete as provided)
    STAKING_ABI: /* ABI array */ [
      {"inputs":[{"internalType":"address","name":"tokenAddress","type":"address"},{"internalType":"address","name":"_managementWallet","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},
      {"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Funded","type":"event"},
      {"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},
      {"anonymous":false,"inputs":[],"name":"Paused","type":"event"},
      {"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"stakeIndex","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"fee","type":"uint256"}],"name":"PrincipalWithdrawn","type":"event"},
      {"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"referrer","type":"address"},{"indexed":true,"internalType":"address","name":"referee","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"ReferralPaid","type":"event"},
      {"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"tokenAddress","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"RescueTokens","type":"event"},
      {"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"amountNet","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"fee","type":"uint256"}],"name":"RewardClaimed","type":"event"},
      {"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":true,"internalType":"uint256","name":"stakeIndex","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":true,"internalType":"address","name":"referrer","type":"address"}],"name":"Staked","type":"event"},
      {"anonymous":false,"inputs":[],"name":"Unpaused","type":"event"},
      {"inputs":[],"name":"BPS_DENOM","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
      {"inputs":[],"name":"MAX_STAKE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
      {"inputs":[],"name":"MIN_STAKE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
      {"inputs":[],"name":"REFERRAL_BPS","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
      {"inputs":[],"name":"STAKE_DURATION","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
      {"inputs":[],"name":"TOTAL_REWARD_MULTIPLIER","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
      {"inputs":[],"name":"WITHDRAWAL_FEE_BPS","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
      {"inputs":[],"name":"availableBalanceForOperations","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
      {"inputs":[{"internalType":"uint256[]","name":"indices","type":"uint256[]"}],"name":"claimStakingRewards","outputs":[],"stateMutability":"nonpayable","type":"function"},
      {"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"fund","outputs":[],"stateMutability":"nonpayable","type":"function"},
      {"inputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint256","name":"index","type":"uint256"}],"name":"getStake","outputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint256","name":"startTime","type":"uint256"},{"internalType":"uint256","name":"claimed","type":"uint256"},{"internalType":"bool","name":"principalWithdrawn","type":"bool"},{"internalType":"uint256","name":"totalReward","type":"uint256"}],"stateMutability":"view","type":"function"},
      {"inputs":[{"internalType":"address","name":"addr","type":"address"}],"name":"isReferrerEligible","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},
      {"inputs":[],"name":"managementWallet","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},
      {"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},
      {"inputs":[],"name":"pause","outputs":[],"stateMutability":"nonpayable","type":"function"},
      {"inputs":[],"name":"paused","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},
      {"inputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint256","name":"index","type":"uint256"}],"name":"pendingRewardForStake","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
      {"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"refereeUsed","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},
      {"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"refereesCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
      {"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"uint256","name":"","type":"uint256"}],"name":"refereesOf","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},
      {"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"referrerOf","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},
      {"inputs":[{"internalType":"address","name":"tokenAddress","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"rescueERC20","outputs":[],"stateMutability":"nonpayable","type":"function"},
      {"inputs":[{"internalType":"address","name":"newWallet","type":"address"}],"name":"setManagementWallet","outputs":[],"stateMutability":"nonpayable","type":"function"},
      {"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"stakeCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
      {"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"address","name":"referrer","type":"address"}],"name":"stakeTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},
      {"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"uint256","name":"","type":"uint256"}],"name":"stakes","outputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint256","name":"startTime","type":"uint256"},{"internalType":"uint256","name":"claimed","type":"uint256"},{"internalType":"bool","name":"principalWithdrawn","type":"bool"},{"internalType":"uint256","name":"totalReward","type":"uint256"}],"stateMutability":"view","type":"function"},
      {"inputs":[],"name":"token","outputs":[{"internalType":"contract IERC20","name":"","type":"address"}],"stateMutability":"view","type":"function"},
      {"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"totalPendingRewards","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
      {"inputs":[],"name":"totalRewardLiability","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
      {"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},
      {"inputs":[],"name":"unpause","outputs":[],"stateMutability":"nonpayable","type":"function"},
      {"inputs":[{"internalType":"uint256[]","name":"indices","type":"uint256[]"}],"name":"withdrawPrincipal","outputs":[],"stateMutability":"nonpayable","type":"function"},
      {"inputs":[],"name":"withdrawReferralRewards","outputs":[],"stateMutability":"pure","type":"function"}
    ],
    TOKEN_ABI: [
      // Minimal ERC20
      {"constant":true,"inputs":[{"name":"account","type":"address"}],"name":"balanceOf","outputs":[{"name":"","type":"uint256"}],"type":"function"},
      {"constant":true,"inputs":[],"name":"decimals","outputs":[{"name":"","type":"uint8"}],"type":"function"},
      {"constant":true,"inputs":[],"name":"symbol","outputs":[{"name":"","type":"string"}],"type":"function"},
      {"constant":false,"inputs":[{"name":"spender","type":"address"},{"name":"amount","type":"uint256"}],"name":"approve","outputs":[{"name":"","type":"bool"}],"type":"function"},
      {"constant":true,"inputs":[{"name":"owner","type":"address"},{"name":"spender","type":"address"}],"name":"allowance","outputs":[{"name":"","type":"uint256"}],"type":"function"}
    ],
    TOKEN_DECIMALS: 18
  };

  /************************************************************************
   * Globals
   ************************************************************************/
  let provider;           // ethers provider (Web3 provider)
  let ethProvider;        // window.ethereum if present
  let signer;
  let userAddress = null;
  let tokenContract;
  let stakingContract;
  let web3Modal;
  let walletConnectProvider;

  // UI refs
  const connectBtn = document.getElementById('connectBtn');
  const addrShort = document.getElementById('addrShort');
  const walletBalance = document.getElementById('walletBalance');
  const stakeAmount = document.getElementById('stakeAmount');
  const referrerInput = document.getElementById('referrer');
  const stakeBtn = document.getElementById('stakeBtn');
  const approveBtn = document.getElementById('approveBtn');
  const stakeSpinner = document.getElementById('stakeSpinner');
  const stakeList = document.getElementById('stakeList');
  const logEl = document.getElementById('log');
  const contractAddrShort = document.getElementById('contractAddrShort');
  const tokenAddrShort = document.getElementById('tokenAddrShort');
  const claimBtn = document.getElementById('claimBtn');
  const withdrawBtn = document.getElementById('withdrawBtn');
  const refreshBtn = document.getElementById('refreshBtn');
  const totalPendingEl = document.getElementById('totalPending');

  /************************************************************************
   * Helpers
   ************************************************************************/
  function writeLog(...args){
    const txt = args.map(a=> (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' ');
    const time = new Date().toLocaleTimeString();
    logEl.textContent = `[${time}] ${txt}\n` + logEl.textContent;
  }
  function shortAddr(addr){ if(!addr) return '—'; return addr.slice(0,6)+'...'+addr.slice(-4); }
  function weiToDecimals(n){ return Number(ethers.utils.formatUnits(n || 0, CONFIG.TOKEN_DECIMALS)); }
  function decimalsToWei(n){ return ethers.utils.parseUnits(String(n || 0), CONFIG.TOKEN_DECIMALS); }
  function safeEnableBtn(btn, cond){ btn.disabled = !cond; }

  /************************************************************************
   * Init Web3Modal + WalletConnect provider
   ************************************************************************/
  function initModal(){
    const providerOptions = {
      walletconnect: {
        package: window.WalletConnectProvider.default,
        options: {
          rpc: { [CONFIG.CHAIN_ID]: CONFIG.RPC },
          chainId: CONFIG.CHAIN_ID
          // Note: for WalletConnect v2 you'd add projectId etc here — user can replace later.
        }
      }
    };

    web3Modal = new window.Web3Modal.default({
      cacheProvider: false,
      providerOptions,
      theme: "dark"
    });
  }

  /************************************************************************
   * Connect / disconnect
   ************************************************************************/
  async function connectWallet(){
    try{
      const instance = await web3Modal.connect();
      provider = new ethers.providers.Web3Provider(instance, "any");
      signer = provider.getSigner();
      ethProvider = instance;

      // detect network
      const network = await provider.getNetwork();
      if(network.chainId !== CONFIG.CHAIN_ID){
        writeLog(`⚠️ Wrong network (connected ${network.chainId}). Please switch to ${CONFIG.NETWORK_NAME} (chainId ${CONFIG.CHAIN_ID}).`);
      }

      userAddress = await signer.getAddress();
      addrShort.textContent = shortAddr(userAddress);
      connectBtn.textContent = 'Connected';
      connectBtn.classList.add('ghost');

      // setup contracts
      tokenContract = new ethers.Contract(CONFIG.TOKEN_CONTRACT_ADDRESS, CONFIG.TOKEN_ABI, signer);
      stakingContract = new ethers.Contract(CONFIG.STAKING_CONTRACT_ADDRESS, CONFIG.STAKING_ABI, signer);

      tokenAddrShort.textContent = shortAddr(CONFIG.TOKEN_CONTRACT_ADDRESS);
      contractAddrShort.textContent = shortAddr(CONFIG.STAKING_CONTRACT_ADDRESS);

      // fetch initial data
      await refreshAll();

      // subscribe to provider events if available
      if(instance.on){
        instance.on("accountsChanged", async (accounts) => {
          writeLog("Accounts changed", accounts);
          if(accounts.length === 0){ disconnect(); return; }
          userAddress = accounts[0];
          addrShort.textContent = shortAddr(userAddress);
          signer = provider.getSigner();
          tokenContract = tokenContract.connect(signer);
          stakingContract = stakingContract.connect(signer);
          await refreshAll();
        });
        instance.on("chainChanged", async (chainId) => {
          writeLog("Chain changed", chainId);
          await refreshAll();
        });
      }
    } catch(err){
      console.error(err);
      writeLog("Connection failed:", err.message || err);
    }
  }

  async function disconnect(){
    provider = null;
    signer = null;
    userAddress = null;
    addrShort.textContent = 'Not connected';
    connectBtn.textContent = 'Connect Wallet';
    connectBtn.classList.remove('ghost');
    stakeList.innerHTML = '';
    walletBalance.textContent = '0 NAVAA';
  }

  /************************************************************************
   * Data fetching + UI rendering
   ************************************************************************/
  // track live update intervals to clear on disconnect
  let liveInterval = null;
  let perStakeState = {}; // store last pending and last retrieved timestamps for smooth per-second growth

  async function refreshAll(){
    if(!signer) return;
    safeEnableBtn(stakeBtn, true);
    safeEnableBtn(claimBtn, true);
    safeEnableBtn(withdrawBtn, true);

    try{
      // wallet balance
      const balRaw = await tokenContract.balanceOf(userAddress);
      walletBalance.textContent = `${weiToDecimals(balRaw).toLocaleString()} NAVAA`;

      // total pending rewards
      const pendingRaw = await stakingContract.totalPendingRewards(userAddress);
      totalPendingEl.textContent = `Pending: ${weiToDecimals(pendingRaw).toFixed(6)}`;

      // stake count
      const count = (await stakingContract.stakeCount(userAddress)).toNumber();
      writeLog(`Found ${count} stakes`);

      // build stakes
      const items = [];
      for(let i=0;i<count;i++){
        const s = await stakingContract.getStake(userAddress, i);
        // getStake returns: amount, startTime, claimed, principalWithdrawn, totalReward
        const stakeObj = {
          index: i,
          amount: s.amount,
          startTime: s.startTime.toNumber(),
          claimed: s.claimed,
          principalWithdrawn: s.principalWithdrawn,
          totalReward: s.totalReward
        };
        // fetch current pending for this stake
        const pending = await stakingContract.pendingRewardForStake(userAddress, i);
        stakeObj.pending = pending;
        items.push(stakeObj);

        // set base perStakeState for live growth
        perStakeState[i] = {
          basePending: pending, // BigNumber
          baseTimestamp: Date.now() // ms
        };
      }

      renderStakeList(items);

      // clear previous interval
      if(liveInterval) clearInterval(liveInterval);
      // update UI every second to show live pending growth
      liveInterval = setInterval(()=> updateLivePending(items), 1000);

    } catch(err){
      console.error(err);
      writeLog("Refresh failed:", err.message || err);
    }
  }

  // Update live pending for each stake (smooth per-second growth)
  function updateLivePending(items){
    items.forEach(item=>{
      const el = document.getElementById(`pending-${item.index}`);
      if(!el) return;
      // compute seconds since baseTimestamp
      const state = perStakeState[item.index];
      if(!state) return;
      const diffSec = Math.floor((Date.now() - state.baseTimestamp)/1000);
      // Since contract accrues linearly, we approximate per-second = (pending accrual rate)
      // We'll compute observed rate by checking difference between totalReward / stakeDuration - but simpler: we can poll pendingRewardForStake regularly.
      // For smoothness, just add diffSec * (0) as placeholder; better approach: poll contract every 15s. Here we visually increment by (0) to avoid incorrect math.
      // To make it accurate, we will request fresh pending from contract every 10 seconds.
      // But for per-second visible growth, we do small micro-increment: compute per-second rate = (totalReward / STAKE_DURATION)
      // Attempt to compute rate if totalReward and STAKE_DURATION available:
      try {
        // item.totalReward / STAKE_DURATION approximate per-second total reward accrual (in wei)
        const totalReward = ethers.BigNumber.from(item.totalReward);
        // STAKE_DURATION we don't have locally; fetch once lazily
        if(window.__STAKE_DURATION__) {
          const perSec = totalReward.div(window.__STAKE_DURATION__ || 1);
          const delta = perSec.mul(ethers.BigNumber.from(diffSec));
          const approx = ethers.BigNumber.from(state.basePending).add(delta);
          el.textContent = formatWeiShort(approx);
        } else {
          // fallback: show base pending only
          el.textContent = formatWeiShort(state.basePending);
        }
      } catch(e){
        el.textContent = formatWeiShort(state.basePending);
      }
    });

    // occasionally refresh authoritative pending from chain (every 12s)
    const t = Date.now();
    if(!window.__lastAuthoritativeRefresh__) window.__lastAuthoritativeRefresh__ = 0;
    if(t - window.__lastAuthoritativeRefresh__ > 12000){
      window.__lastAuthoritativeRefresh__ = t;
      // re-fetch all pending and update base states
      if(signingReady()) {
        (async ()=>{
          try{
            const count = (await stakingContract.stakeCount(userAddress)).toNumber();
            for(let i=0;i<count;i++){
              const pending = await stakingContract.pendingRewardForStake(userAddress, i);
              perStakeState[i].basePending = pending;
              perStakeState[i].baseTimestamp = Date.now();
              const el = document.getElementById(`pending-${i}`);
              if(el) el.textContent = formatWeiShort(pending);
            }
            const tbal = await stakingContract.totalPendingRewards(userAddress);
            totalPendingEl.textContent = `Pending: ${weiToDecimals(tbal).toFixed(6)}`;
          }catch(e){ /* ignore */ }
        })();
      }
    }
  }

  function formatWeiShort(bn){
    try{
      return Number(ethers.utils.formatUnits(bn, CONFIG.TOKEN_DECIMALS)).toFixed(6);
    }catch(e){ return "0.000000" }
  }

  function renderStakeList(items){
    stakeList.innerHTML = '';
    // compute current time to check matured
    const now = Math.floor(Date.now()/1000);
    // We'll fetch STAKE_DURATION if not yet
    (async ()=>{
      try{
        if(!window.__STAKE_DURATION__){
          const sd = await stakingContract.STAKE_DURATION();
          window.__STAKE_DURATION__ = sd.toNumber();
        }
      }catch(e){}
    })();

    items.forEach(it=>{
      const matured = (now >= it.startTime + (window.__STAKE_DURATION__ || 0));
      const claimed = Number(ethers.utils.formatUnits(it.claimed || 0, CONFIG.TOKEN_DECIMALS));
      const totalReward = Number(ethers.utils.formatUnits(it.totalReward || 0, CONFIG.TOKEN_DECIMALS));
      const amount = Number(ethers.utils.formatUnits(it.amount || 0, CONFIG.TOKEN_DECIMALS));
      const pending = formatWeiShort(it.pending || 0);

      const node = document.createElement('div');
      node.className = 'stake-item';
      node.innerHTML = `
        <div style="width:28px">
          <input class="checkbox" type="checkbox" id="chk-${it.index}" data-index="${it.index}">
        </div>
        <div class="stake-left">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <div style="font-weight:700">#${it.index} — ${amount.toLocaleString()} NAVAA</div>
            <div class="tiny-muted">${matured ? '<span class="green">Matured</span>' : '<span class="badge">Lock</span>'}</div>
          </div>
          <div class="stake-meta" style="margin-top:8px;">
            <div class="tiny-muted">Start: ${new Date(it.startTime*1000).toLocaleString()}</div>
            <div class="tiny-muted">Claimed: ${claimed.toFixed(6)}</div>
            <div class="tiny-muted">TotalReward: ${totalReward.toFixed(6)}</div>
          </div>
        </div>
        <div style="text-align:right; min-width:140px">
          <div style="font-weight:700" id="pending-${it.index}">${pending}</div>
          <div class="tiny-muted">Pending (live)</div>
        </div>
      `;
      stakeList.appendChild(node);
    });
  }

  function signingReady(){ return !!(signer && userAddress && stakingContract); }

  /************************************************************************
   * Actions: Approve, Stake, Claim, Withdraw
   ************************************************************************/
  approveBtn.addEventListener('click', async ()=>{
    if(!signingReady()){ writeLog('Connect wallet first'); return; }
    try{
      approveBtn.disabled = true;
      writeLog('Approving token allowance for staking contract...');
      const max = ethers.constants.MaxUint256;
      const tx = await tokenContract.approve(CONFIG.STAKING_CONTRACT_ADDRESS, max);
      writeLog('Approve tx sent:', tx.hash);
      await tx.wait();
      writeLog('Approved.');
    }catch(e){ writeLog('Approve error:', e.message || e); }
    approveBtn.disabled = false;
  });

  stakeBtn.addEventListener('click', async ()=>{
    if(!signingReady()){ writeLog('Connect wallet first'); return; }
    const amt = Number(stakeAmount.value);
    if(!amt || amt <= 0){ writeLog('Enter valid amount'); return; }
    const ref = referrerInput.value.trim();
    try{
      stakeBtn.disabled = true; stakeSpinner.style.display = 'inline-block';
      writeLog('Staking', amt, 'NAVAA ...');
      const wei = decimalsToWei(amt);
      const refAddr = (ref && ethers.utils.isAddress(ref)) ? ref : ethers.constants.AddressZero;
      const tx = await stakingContract.stakeTokens(wei, refAddr);
      writeLog('Stake tx:', tx.hash);
      await tx.wait();
      writeLog('Staking confirmed');
      await refreshAll();
    }catch(e){
      writeLog('Stake failed:', e.message || e);
    }finally{
      stakeBtn.disabled = false; stakeSpinner.style.display = 'none';
    }
  });

  claimBtn.addEventListener('click', async ()=>{
    if(!signingReady()){ writeLog('Connect wallet first'); return; }
    const indices = getSelectedIndices();
    if(indices.length === 0){ writeLog('Select stakes to claim'); return; }
    try{
      claimBtn.disabled = true; document.getElementById('claimSpinner').style.display = 'inline-block';
      writeLog('Claiming rewards for', indices);
      const tx = await stakingContract.claimStakingRewards(indices);
      writeLog('Claim tx:', tx.hash);
      await tx.wait();
      writeLog('Claim confirmed');
      await refreshAll();
    }catch(e){ writeLog('Claim failed:', e.message || e); }
    finally{ claimBtn.disabled = false; document.getElementById('claimSpinner').style.display = 'none'; }
  });

  withdrawBtn.addEventListener('click', async ()=>{
    if(!signingReady()){ writeLog('Connect wallet first'); return; }
    const indices = getSelectedIndices();
    if(indices.length === 0){ writeLog('Select stakes to withdraw principal'); return; }
    try{
      withdrawBtn.disabled = true; document.getElementById('withdrawSpinner').style.display = 'inline-block';
      writeLog('Withdrawing principal for', indices);
      const tx = await stakingContract.withdrawPrincipal(indices);
      writeLog('Withdraw tx:', tx.hash);
      await tx.wait();
      writeLog('Withdraw confirmed');
      await refreshAll();
    }catch(e){ writeLog('Withdraw failed:', e.message || e); }
    finally{ withdrawBtn.disabled = false; document.getElementById('withdrawSpinner').style.display = 'none'; }
  });

  // helper to get selected indices from checkboxes
  function getSelectedIndices(){
    const arr = [];
    const boxes = document.querySelectorAll('.stake-list input[type="checkbox"]');
    boxes.forEach(cb=>{
      if(cb.checked) arr.push(Number(cb.dataset.index));
    });
    return arr;
  }

  // refresh button
  refreshBtn.addEventListener('click', async ()=>{ refreshBtn.disabled = true; await refreshAll(); refreshBtn.disabled = false; });

  document.getElementById('clearLog').addEventListener('click', ()=>{ logEl.textContent = ''; });

  /************************************************************************
   * Boot
   ************************************************************************/
  (function boot(){
    initModal();
    connectBtn.addEventListener('click', async ()=>{
      if(!userAddress) await connectWallet();
      else { /* already connected */ writeLog('Already connected'); }
    });

    // quick info
    document.getElementById('tokenAddrShort').textContent = shortAddr(CONFIG.TOKEN_CONTRACT_ADDRESS);
    document.getElementById('contractAddrShort').textContent = shortAddr(CONFIG.STAKING_CONTRACT_ADDRESS);
    writeLog('UI ready — connect wallet to begin');
  })();

  // attempt auto-setup of a read-only provider so users can view contract info even before connecting
  (async ()=>{
    try{
      const readonlyProvider = new ethers.providers.JsonRpcProvider(CONFIG.RPC, CONFIG.CHAIN_ID);
      const readStaking = new ethers.Contract(CONFIG.STAKING_CONTRACT_ADDRESS, CONFIG.STAKING_ABI, readonlyProvider);
      const management = await readStaking.managementWallet();
      document.getElementById('managementWallet').textContent = `Mgmt: ${shortAddr(management)}`;
      // attempt to fetch STAKE_DURATION for per-second math
      try{
        const sd = await readStaking.STAKE_DURATION();
        window.__STAKE_DURATION__ = sd.toNumber();
        writeLog('Stake duration:', window.__STAKE_DURATION__, 'seconds');
      }catch(e){}
    }catch(e){
      // ignore
    }
  })();

  </script>
</body>
</html>

